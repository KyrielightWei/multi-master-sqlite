// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: os_remote.proto
#ifndef GRPC_os_5fremote_2eproto__INCLUDED
#define GRPC_os_5fremote_2eproto__INCLUDED

#include "os_remote.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace os_remote {

class OSRemote final {
 public:
  static constexpr char const* service_full_name() {
    return "os_remote.OSRemote";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Init(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncInit(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncInit(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncInitRaw(context, request, cq));
    }
    virtual ::grpc::Status Open(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncOpen(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncOpenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncOpen(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncOpenRaw(context, request, cq));
    }
    virtual ::grpc::Status Delete(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncDelete(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncDelete(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncDeleteRaw(context, request, cq));
    }
    virtual ::grpc::Status Access(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncAccess(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncAccessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncAccess(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncAccessRaw(context, request, cq));
    }
    virtual ::grpc::Status FullPathname(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncFullPathname(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncFullPathnameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncFullPathname(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncFullPathnameRaw(context, request, cq));
    }
    virtual ::grpc::Status Randomness(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncRandomness(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncRandomnessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncRandomness(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncRandomnessRaw(context, request, cq));
    }
    virtual ::grpc::Status Sleep(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncSleep(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncSleepRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncSleep(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncSleepRaw(context, request, cq));
    }
    virtual ::grpc::Status CurrentTime(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncCurrentTime(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncCurrentTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncCurrentTime(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncCurrentTimeRaw(context, request, cq));
    }
    virtual ::grpc::Status GetLastError(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncGetLastError(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncGetLastErrorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncGetLastError(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncGetLastErrorRaw(context, request, cq));
    }
    virtual ::grpc::Status CurrentTimeInt64(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncCurrentTimeInt64(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncCurrentTimeInt64Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncCurrentTimeInt64(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncCurrentTimeInt64Raw(context, request, cq));
    }
    virtual ::grpc::Status Write(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncWrite(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncWrite(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncWriteRaw(context, request, cq));
    }
    virtual ::grpc::Status Read(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncRead(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncRead(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncReadRaw(context, request, cq));
    }
    virtual ::grpc::Status Truncate(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncTruncate(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncTruncateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncTruncate(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncTruncateRaw(context, request, cq));
    }
    virtual ::grpc::Status Sync(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncSync(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncSync(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncSyncRaw(context, request, cq));
    }
    virtual ::grpc::Status FileSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncFileSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncFileSizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncFileSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncFileSizeRaw(context, request, cq));
    }
    virtual ::grpc::Status FileControl(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncFileControl(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncFileControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncFileControl(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncFileControlRaw(context, request, cq));
    }
    virtual ::grpc::Status SectorSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncSectorSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncSectorSizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncSectorSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncSectorSizeRaw(context, request, cq));
    }
    virtual ::grpc::Status DeviceCharacteristics(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncDeviceCharacteristics(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncDeviceCharacteristicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncDeviceCharacteristics(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncDeviceCharacteristicsRaw(context, request, cq));
    }
    virtual ::grpc::Status Close(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncClose(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncCloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncClose(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncCloseRaw(context, request, cq));
    }
    virtual ::grpc::Status Lock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncLockRaw(context, request, cq));
    }
    virtual ::grpc::Status Unlock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncUnlock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncUnlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncUnlock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncUnlockRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckReservedLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncCheckReservedLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncCheckReservedLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncCheckReservedLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncCheckReservedLockRaw(context, request, cq));
    }
    virtual ::grpc::Status Fetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncFetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncFetchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncFetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncFetchRaw(context, request, cq));
    }
    virtual ::grpc::Status Unfetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> AsyncUnfetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(AsyncUnfetchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>> PrepareAsyncUnfetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>>(PrepareAsyncUnfetchRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void Init(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Init(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Init(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Init(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Open(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Open(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Open(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Open(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Delete(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Delete(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Access(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Access(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Access(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Access(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void FullPathname(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FullPathname(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FullPathname(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void FullPathname(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Randomness(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Randomness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Randomness(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Randomness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Sleep(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Sleep(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Sleep(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Sleep(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CurrentTime(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CurrentTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CurrentTime(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CurrentTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetLastError(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLastError(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLastError(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetLastError(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CurrentTimeInt64(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CurrentTimeInt64(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CurrentTimeInt64(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CurrentTimeInt64(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Write(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Write(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Read(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Read(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Truncate(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Truncate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Truncate(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Truncate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Sync(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Sync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Sync(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Sync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void FileSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FileSize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FileSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void FileSize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void FileControl(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FileControl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FileControl(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void FileControl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SectorSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SectorSize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SectorSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SectorSize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeviceCharacteristics(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeviceCharacteristics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeviceCharacteristics(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeviceCharacteristics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Close(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Close(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Close(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Close(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Lock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Lock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Lock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Lock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Unlock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Unlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Unlock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Unlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CheckReservedLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckReservedLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckReservedLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void CheckReservedLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Fetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Fetch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Fetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Fetch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Unfetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Unfetch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Unfetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Unfetch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncInitRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncInitRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncOpenRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncOpenRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncDeleteRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncDeleteRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncAccessRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncAccessRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncFullPathnameRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncFullPathnameRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncRandomnessRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncRandomnessRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncSleepRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncSleepRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncCurrentTimeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncCurrentTimeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncGetLastErrorRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncGetLastErrorRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncCurrentTimeInt64Raw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncCurrentTimeInt64Raw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncWriteRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncWriteRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncReadRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncReadRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncTruncateRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncTruncateRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncSyncRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncSyncRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncFileSizeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncFileSizeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncFileControlRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncFileControlRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncSectorSizeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncSectorSizeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncDeviceCharacteristicsRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncDeviceCharacteristicsRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncCloseRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncCloseRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncLockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncLockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncUnlockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncUnlockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncCheckReservedLockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncCheckReservedLockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncFetchRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncFetchRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* AsyncUnfetchRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::os_remote::ArgReply>* PrepareAsyncUnfetchRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Init(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncInit(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncInit(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncInitRaw(context, request, cq));
    }
    ::grpc::Status Open(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncOpen(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncOpenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncOpen(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncOpenRaw(context, request, cq));
    }
    ::grpc::Status Delete(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncDelete(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncDelete(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncDeleteRaw(context, request, cq));
    }
    ::grpc::Status Access(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncAccess(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncAccessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncAccess(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncAccessRaw(context, request, cq));
    }
    ::grpc::Status FullPathname(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncFullPathname(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncFullPathnameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncFullPathname(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncFullPathnameRaw(context, request, cq));
    }
    ::grpc::Status Randomness(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncRandomness(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncRandomnessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncRandomness(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncRandomnessRaw(context, request, cq));
    }
    ::grpc::Status Sleep(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncSleep(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncSleepRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncSleep(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncSleepRaw(context, request, cq));
    }
    ::grpc::Status CurrentTime(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncCurrentTime(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncCurrentTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncCurrentTime(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncCurrentTimeRaw(context, request, cq));
    }
    ::grpc::Status GetLastError(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncGetLastError(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncGetLastErrorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncGetLastError(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncGetLastErrorRaw(context, request, cq));
    }
    ::grpc::Status CurrentTimeInt64(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncCurrentTimeInt64(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncCurrentTimeInt64Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncCurrentTimeInt64(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncCurrentTimeInt64Raw(context, request, cq));
    }
    ::grpc::Status Write(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncWrite(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncWrite(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncWriteRaw(context, request, cq));
    }
    ::grpc::Status Read(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncRead(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncRead(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncReadRaw(context, request, cq));
    }
    ::grpc::Status Truncate(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncTruncate(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncTruncateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncTruncate(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncTruncateRaw(context, request, cq));
    }
    ::grpc::Status Sync(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncSync(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncSyncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncSync(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncSyncRaw(context, request, cq));
    }
    ::grpc::Status FileSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncFileSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncFileSizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncFileSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncFileSizeRaw(context, request, cq));
    }
    ::grpc::Status FileControl(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncFileControl(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncFileControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncFileControl(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncFileControlRaw(context, request, cq));
    }
    ::grpc::Status SectorSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncSectorSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncSectorSizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncSectorSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncSectorSizeRaw(context, request, cq));
    }
    ::grpc::Status DeviceCharacteristics(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncDeviceCharacteristics(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncDeviceCharacteristicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncDeviceCharacteristics(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncDeviceCharacteristicsRaw(context, request, cq));
    }
    ::grpc::Status Close(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncClose(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncCloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncClose(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncCloseRaw(context, request, cq));
    }
    ::grpc::Status Lock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncLockRaw(context, request, cq));
    }
    ::grpc::Status Unlock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncUnlock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncUnlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncUnlock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncUnlockRaw(context, request, cq));
    }
    ::grpc::Status CheckReservedLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncCheckReservedLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncCheckReservedLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncCheckReservedLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncCheckReservedLockRaw(context, request, cq));
    }
    ::grpc::Status Fetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncFetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncFetchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncFetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncFetchRaw(context, request, cq));
    }
    ::grpc::Status Unfetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::os_remote::ArgReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> AsyncUnfetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(AsyncUnfetchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>> PrepareAsyncUnfetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>>(PrepareAsyncUnfetchRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Init(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Init(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Init(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Init(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Open(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Open(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Open(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Open(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Delete(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Delete(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Access(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Access(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Access(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Access(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void FullPathname(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void FullPathname(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void FullPathname(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void FullPathname(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Randomness(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Randomness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Randomness(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Randomness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Sleep(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Sleep(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Sleep(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Sleep(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CurrentTime(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void CurrentTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void CurrentTime(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CurrentTime(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetLastError(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void GetLastError(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void GetLastError(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetLastError(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CurrentTimeInt64(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void CurrentTimeInt64(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void CurrentTimeInt64(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CurrentTimeInt64(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Write(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Write(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Write(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Read(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Read(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Truncate(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Truncate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Truncate(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Truncate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Sync(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Sync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Sync(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Sync(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void FileSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void FileSize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void FileSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void FileSize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void FileControl(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void FileControl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void FileControl(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void FileControl(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SectorSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void SectorSize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void SectorSize(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SectorSize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeviceCharacteristics(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void DeviceCharacteristics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void DeviceCharacteristics(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeviceCharacteristics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Close(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Close(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Close(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Close(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Lock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Lock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Lock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Lock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Unlock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Unlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Unlock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Unlock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CheckReservedLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void CheckReservedLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void CheckReservedLock(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void CheckReservedLock(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Fetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Fetch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Fetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Fetch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Unfetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Unfetch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, std::function<void(::grpc::Status)>) override;
      void Unfetch(::grpc::ClientContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Unfetch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::os_remote::ArgReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncInitRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncInitRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncOpenRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncOpenRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncDeleteRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncDeleteRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncAccessRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncAccessRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncFullPathnameRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncFullPathnameRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncRandomnessRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncRandomnessRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncSleepRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncSleepRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncCurrentTimeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncCurrentTimeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncGetLastErrorRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncGetLastErrorRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncCurrentTimeInt64Raw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncCurrentTimeInt64Raw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncWriteRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncWriteRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncReadRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncReadRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncTruncateRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncTruncateRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncSyncRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncSyncRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncFileSizeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncFileSizeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncFileControlRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncFileControlRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncSectorSizeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncSectorSizeRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncDeviceCharacteristicsRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncDeviceCharacteristicsRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncCloseRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncCloseRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncLockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncLockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncUnlockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncUnlockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncCheckReservedLockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncCheckReservedLockRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncFetchRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncFetchRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* AsyncUnfetchRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::os_remote::ArgReply>* PrepareAsyncUnfetchRaw(::grpc::ClientContext* context, const ::os_remote::ArgRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Init_;
    const ::grpc::internal::RpcMethod rpcmethod_Open_;
    const ::grpc::internal::RpcMethod rpcmethod_Delete_;
    const ::grpc::internal::RpcMethod rpcmethod_Access_;
    const ::grpc::internal::RpcMethod rpcmethod_FullPathname_;
    const ::grpc::internal::RpcMethod rpcmethod_Randomness_;
    const ::grpc::internal::RpcMethod rpcmethod_Sleep_;
    const ::grpc::internal::RpcMethod rpcmethod_CurrentTime_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLastError_;
    const ::grpc::internal::RpcMethod rpcmethod_CurrentTimeInt64_;
    const ::grpc::internal::RpcMethod rpcmethod_Write_;
    const ::grpc::internal::RpcMethod rpcmethod_Read_;
    const ::grpc::internal::RpcMethod rpcmethod_Truncate_;
    const ::grpc::internal::RpcMethod rpcmethod_Sync_;
    const ::grpc::internal::RpcMethod rpcmethod_FileSize_;
    const ::grpc::internal::RpcMethod rpcmethod_FileControl_;
    const ::grpc::internal::RpcMethod rpcmethod_SectorSize_;
    const ::grpc::internal::RpcMethod rpcmethod_DeviceCharacteristics_;
    const ::grpc::internal::RpcMethod rpcmethod_Close_;
    const ::grpc::internal::RpcMethod rpcmethod_Lock_;
    const ::grpc::internal::RpcMethod rpcmethod_Unlock_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckReservedLock_;
    const ::grpc::internal::RpcMethod rpcmethod_Fetch_;
    const ::grpc::internal::RpcMethod rpcmethod_Unfetch_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Init(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Open(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Delete(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Access(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status FullPathname(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Randomness(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Sleep(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status CurrentTime(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status GetLastError(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status CurrentTimeInt64(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Write(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Read(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Truncate(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Sync(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status FileSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status FileControl(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status SectorSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status DeviceCharacteristics(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Close(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Lock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Unlock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status CheckReservedLock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Fetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
    virtual ::grpc::Status Unfetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Init() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Init(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInit(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Open() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpen(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Delete() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDelete(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Access : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Access() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Access() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Access(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAccess(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FullPathname : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_FullPathname() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_FullPathname() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullPathname(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFullPathname(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Randomness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Randomness() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Randomness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Randomness(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRandomness(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Sleep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Sleep() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Sleep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sleep(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSleep(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CurrentTime() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_CurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTime(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCurrentTime(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLastError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetLastError() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetLastError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLastError(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLastError(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CurrentTimeInt64 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CurrentTimeInt64() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_CurrentTimeInt64() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTimeInt64(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCurrentTimeInt64(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Write() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWrite(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Read() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRead(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Truncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Truncate() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_Truncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Truncate(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTruncate(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Sync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Sync() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_Sync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sync(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSync(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FileSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_FileSize() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_FileSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFileSize(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FileControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_FileControl() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_FileControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileControl(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFileControl(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SectorSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SectorSize() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_SectorSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SectorSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSectorSize(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeviceCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeviceCharacteristics() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_DeviceCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeviceCharacteristics(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeviceCharacteristics(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Close() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClose(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Lock() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Lock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLock(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Unlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Unlock() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_Unlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unlock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlock(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckReservedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CheckReservedLock() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_CheckReservedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReservedLock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckReservedLock(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Fetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Fetch() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetch(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Unfetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Unfetch() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_Unfetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unfetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnfetch(::grpc::ServerContext* context, ::os_remote::ArgRequest* request, ::grpc::ServerAsyncResponseWriter< ::os_remote::ArgReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Init<WithAsyncMethod_Open<WithAsyncMethod_Delete<WithAsyncMethod_Access<WithAsyncMethod_FullPathname<WithAsyncMethod_Randomness<WithAsyncMethod_Sleep<WithAsyncMethod_CurrentTime<WithAsyncMethod_GetLastError<WithAsyncMethod_CurrentTimeInt64<WithAsyncMethod_Write<WithAsyncMethod_Read<WithAsyncMethod_Truncate<WithAsyncMethod_Sync<WithAsyncMethod_FileSize<WithAsyncMethod_FileControl<WithAsyncMethod_SectorSize<WithAsyncMethod_DeviceCharacteristics<WithAsyncMethod_Close<WithAsyncMethod_Lock<WithAsyncMethod_Unlock<WithAsyncMethod_CheckReservedLock<WithAsyncMethod_Fetch<WithAsyncMethod_Unfetch<Service > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Init() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Init(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Init(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Init(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Init(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Open() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Open(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Open(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Open(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Delete() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Delete(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Delete(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Delete(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Access : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Access() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Access(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Access(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Access() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Access(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Access(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FullPathname : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_FullPathname() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->FullPathname(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_FullPathname(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FullPathname() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullPathname(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void FullPathname(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Randomness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Randomness() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Randomness(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Randomness(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Randomness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Randomness(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Randomness(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Sleep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Sleep() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Sleep(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Sleep(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Sleep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sleep(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Sleep(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CurrentTime() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CurrentTime(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CurrentTime(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTime(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CurrentTime(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetLastError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetLastError() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetLastError(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetLastError(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetLastError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLastError(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetLastError(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CurrentTimeInt64 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CurrentTimeInt64() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CurrentTimeInt64(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CurrentTimeInt64(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CurrentTimeInt64() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTimeInt64(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CurrentTimeInt64(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Write() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Write(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Write(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Write(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Read() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Read(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Read(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Read(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Truncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Truncate() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Truncate(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Truncate(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Truncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Truncate(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Truncate(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Sync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Sync() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Sync(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Sync(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Sync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sync(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Sync(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FileSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_FileSize() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->FileSize(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_FileSize(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FileSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void FileSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FileControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_FileControl() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->FileControl(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_FileControl(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FileControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileControl(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void FileControl(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SectorSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SectorSize() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SectorSize(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SectorSize(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SectorSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SectorSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SectorSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeviceCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DeviceCharacteristics() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DeviceCharacteristics(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DeviceCharacteristics(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeviceCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeviceCharacteristics(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeviceCharacteristics(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Close() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Close(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Close(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(18))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Close(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Lock() {
      ::grpc::Service::experimental().MarkMethodCallback(19,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Lock(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Lock(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(19))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Lock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Lock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Unlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Unlock() {
      ::grpc::Service::experimental().MarkMethodCallback(20,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Unlock(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Unlock(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(20))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Unlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unlock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Unlock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CheckReservedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_CheckReservedLock() {
      ::grpc::Service::experimental().MarkMethodCallback(21,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->CheckReservedLock(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_CheckReservedLock(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(21))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CheckReservedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReservedLock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CheckReservedLock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Fetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Fetch() {
      ::grpc::Service::experimental().MarkMethodCallback(22,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Fetch(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Fetch(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(22))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Fetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Unfetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Unfetch() {
      ::grpc::Service::experimental().MarkMethodCallback(23,
        new ::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(
          [this](::grpc::ServerContext* context,
                 const ::os_remote::ArgRequest* request,
                 ::os_remote::ArgReply* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Unfetch(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Unfetch(
        ::grpc::experimental::MessageAllocator< ::os_remote::ArgRequest, ::os_remote::ArgReply>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>*>(
          ::grpc::Service::experimental().GetHandler(23))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Unfetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unfetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Unfetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_Init<ExperimentalWithCallbackMethod_Open<ExperimentalWithCallbackMethod_Delete<ExperimentalWithCallbackMethod_Access<ExperimentalWithCallbackMethod_FullPathname<ExperimentalWithCallbackMethod_Randomness<ExperimentalWithCallbackMethod_Sleep<ExperimentalWithCallbackMethod_CurrentTime<ExperimentalWithCallbackMethod_GetLastError<ExperimentalWithCallbackMethod_CurrentTimeInt64<ExperimentalWithCallbackMethod_Write<ExperimentalWithCallbackMethod_Read<ExperimentalWithCallbackMethod_Truncate<ExperimentalWithCallbackMethod_Sync<ExperimentalWithCallbackMethod_FileSize<ExperimentalWithCallbackMethod_FileControl<ExperimentalWithCallbackMethod_SectorSize<ExperimentalWithCallbackMethod_DeviceCharacteristics<ExperimentalWithCallbackMethod_Close<ExperimentalWithCallbackMethod_Lock<ExperimentalWithCallbackMethod_Unlock<ExperimentalWithCallbackMethod_CheckReservedLock<ExperimentalWithCallbackMethod_Fetch<ExperimentalWithCallbackMethod_Unfetch<Service > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Init() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Init(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Open() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Delete() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Access : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Access() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Access() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Access(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FullPathname : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_FullPathname() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_FullPathname() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullPathname(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Randomness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Randomness() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Randomness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Randomness(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Sleep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Sleep() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Sleep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sleep(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CurrentTime() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_CurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTime(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLastError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetLastError() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetLastError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLastError(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CurrentTimeInt64 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CurrentTimeInt64() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_CurrentTimeInt64() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTimeInt64(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Write() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Read() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Truncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Truncate() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_Truncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Truncate(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Sync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Sync() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_Sync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sync(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FileSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_FileSize() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_FileSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FileControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_FileControl() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_FileControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileControl(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SectorSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SectorSize() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_SectorSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SectorSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeviceCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeviceCharacteristics() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_DeviceCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeviceCharacteristics(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Close() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Lock() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Lock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Unlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Unlock() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_Unlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unlock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckReservedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CheckReservedLock() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_CheckReservedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReservedLock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Fetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Fetch() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Unfetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Unfetch() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_Unfetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unfetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Init() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Init(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Open() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpen(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Delete() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDelete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Access : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Access() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Access() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Access(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAccess(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FullPathname : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_FullPathname() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_FullPathname() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullPathname(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFullPathname(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Randomness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Randomness() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Randomness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Randomness(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRandomness(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Sleep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Sleep() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_Sleep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sleep(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSleep(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CurrentTime() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_CurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTime(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCurrentTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLastError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetLastError() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetLastError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLastError(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLastError(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CurrentTimeInt64 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CurrentTimeInt64() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_CurrentTimeInt64() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTimeInt64(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCurrentTimeInt64(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Write() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Read() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRead(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Truncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Truncate() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_Truncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Truncate(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTruncate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Sync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Sync() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_Sync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sync(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSync(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FileSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_FileSize() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_FileSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFileSize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FileControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_FileControl() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_FileControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileControl(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFileControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SectorSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SectorSize() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_SectorSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SectorSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSectorSize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeviceCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeviceCharacteristics() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_DeviceCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeviceCharacteristics(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeviceCharacteristics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Close() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Lock() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Lock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Unlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Unlock() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_Unlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unlock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckReservedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CheckReservedLock() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_CheckReservedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReservedLock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckReservedLock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Fetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Fetch() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Unfetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Unfetch() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_Unfetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unfetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnfetch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Init() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Init(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Init(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Init(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Open() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Open(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Open(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Delete() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Delete(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Delete(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Access : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Access() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Access(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Access() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Access(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Access(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FullPathname : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_FullPathname() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->FullPathname(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_FullPathname() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FullPathname(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void FullPathname(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Randomness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Randomness() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Randomness(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Randomness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Randomness(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Randomness(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Sleep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Sleep() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Sleep(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Sleep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sleep(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Sleep(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CurrentTime() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CurrentTime(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTime(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CurrentTime(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetLastError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetLastError() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetLastError(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetLastError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLastError(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetLastError(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CurrentTimeInt64 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CurrentTimeInt64() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CurrentTimeInt64(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CurrentTimeInt64() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTimeInt64(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CurrentTimeInt64(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Write() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Write(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Write(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Read() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Read(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Read(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Truncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Truncate() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Truncate(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Truncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Truncate(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Truncate(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Sync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Sync() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Sync(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Sync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sync(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Sync(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FileSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_FileSize() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->FileSize(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_FileSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void FileSize(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FileControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_FileControl() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->FileControl(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_FileControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FileControl(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void FileControl(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SectorSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SectorSize() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SectorSize(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SectorSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SectorSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SectorSize(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeviceCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DeviceCharacteristics() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DeviceCharacteristics(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DeviceCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeviceCharacteristics(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeviceCharacteristics(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Close() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Close(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Close(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Lock() {
      ::grpc::Service::experimental().MarkMethodRawCallback(19,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Lock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Lock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Lock(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Unlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Unlock() {
      ::grpc::Service::experimental().MarkMethodRawCallback(20,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Unlock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Unlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unlock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Unlock(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CheckReservedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_CheckReservedLock() {
      ::grpc::Service::experimental().MarkMethodRawCallback(21,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->CheckReservedLock(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_CheckReservedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckReservedLock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void CheckReservedLock(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Fetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Fetch() {
      ::grpc::Service::experimental().MarkMethodRawCallback(22,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Fetch(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Fetch(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Unfetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Unfetch() {
      ::grpc::Service::experimental().MarkMethodRawCallback(23,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Unfetch(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Unfetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unfetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Unfetch(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Init : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Init() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Init<BaseClass>::StreamedInit, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Init() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Init(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Open() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Open<BaseClass>::StreamedOpen, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Open(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOpen(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Delete() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Delete<BaseClass>::StreamedDelete, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Delete(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDelete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Access : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Access() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Access<BaseClass>::StreamedAccess, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Access() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Access(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAccess(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FullPathname : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_FullPathname() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_FullPathname<BaseClass>::StreamedFullPathname, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_FullPathname() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FullPathname(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFullPathname(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Randomness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Randomness() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Randomness<BaseClass>::StreamedRandomness, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Randomness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Randomness(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRandomness(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Sleep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Sleep() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Sleep<BaseClass>::StreamedSleep, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Sleep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Sleep(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSleep(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CurrentTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CurrentTime() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_CurrentTime<BaseClass>::StreamedCurrentTime, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CurrentTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CurrentTime(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCurrentTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLastError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetLastError() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_GetLastError<BaseClass>::StreamedGetLastError, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetLastError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLastError(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLastError(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CurrentTimeInt64 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CurrentTimeInt64() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_CurrentTimeInt64<BaseClass>::StreamedCurrentTimeInt64, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CurrentTimeInt64() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CurrentTimeInt64(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCurrentTimeInt64(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Write() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Write<BaseClass>::StreamedWrite, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Write(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Read() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Read<BaseClass>::StreamedRead, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Read(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRead(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Truncate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Truncate() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Truncate<BaseClass>::StreamedTruncate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Truncate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Truncate(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTruncate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Sync : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Sync() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Sync<BaseClass>::StreamedSync, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Sync() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Sync(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSync(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FileSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_FileSize() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_FileSize<BaseClass>::StreamedFileSize, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_FileSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FileSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFileSize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FileControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_FileControl() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_FileControl<BaseClass>::StreamedFileControl, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_FileControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FileControl(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFileControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SectorSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SectorSize() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_SectorSize<BaseClass>::StreamedSectorSize, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SectorSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SectorSize(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSectorSize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeviceCharacteristics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeviceCharacteristics() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_DeviceCharacteristics<BaseClass>::StreamedDeviceCharacteristics, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeviceCharacteristics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeviceCharacteristics(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeviceCharacteristics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Close() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Close<BaseClass>::StreamedClose, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Close(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Lock() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Lock<BaseClass>::StreamedLock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Lock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Unlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Unlock() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Unlock<BaseClass>::StreamedUnlock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Unlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Unlock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckReservedLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CheckReservedLock() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_CheckReservedLock<BaseClass>::StreamedCheckReservedLock, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CheckReservedLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckReservedLock(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckReservedLock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Fetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Fetch() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Fetch<BaseClass>::StreamedFetch, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFetch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Unfetch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Unfetch() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::os_remote::ArgRequest, ::os_remote::ArgReply>(std::bind(&WithStreamedUnaryMethod_Unfetch<BaseClass>::StreamedUnfetch, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Unfetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Unfetch(::grpc::ServerContext* context, const ::os_remote::ArgRequest* request, ::os_remote::ArgReply* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnfetch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::os_remote::ArgRequest,::os_remote::ArgReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Init<WithStreamedUnaryMethod_Open<WithStreamedUnaryMethod_Delete<WithStreamedUnaryMethod_Access<WithStreamedUnaryMethod_FullPathname<WithStreamedUnaryMethod_Randomness<WithStreamedUnaryMethod_Sleep<WithStreamedUnaryMethod_CurrentTime<WithStreamedUnaryMethod_GetLastError<WithStreamedUnaryMethod_CurrentTimeInt64<WithStreamedUnaryMethod_Write<WithStreamedUnaryMethod_Read<WithStreamedUnaryMethod_Truncate<WithStreamedUnaryMethod_Sync<WithStreamedUnaryMethod_FileSize<WithStreamedUnaryMethod_FileControl<WithStreamedUnaryMethod_SectorSize<WithStreamedUnaryMethod_DeviceCharacteristics<WithStreamedUnaryMethod_Close<WithStreamedUnaryMethod_Lock<WithStreamedUnaryMethod_Unlock<WithStreamedUnaryMethod_CheckReservedLock<WithStreamedUnaryMethod_Fetch<WithStreamedUnaryMethod_Unfetch<Service > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Init<WithStreamedUnaryMethod_Open<WithStreamedUnaryMethod_Delete<WithStreamedUnaryMethod_Access<WithStreamedUnaryMethod_FullPathname<WithStreamedUnaryMethod_Randomness<WithStreamedUnaryMethod_Sleep<WithStreamedUnaryMethod_CurrentTime<WithStreamedUnaryMethod_GetLastError<WithStreamedUnaryMethod_CurrentTimeInt64<WithStreamedUnaryMethod_Write<WithStreamedUnaryMethod_Read<WithStreamedUnaryMethod_Truncate<WithStreamedUnaryMethod_Sync<WithStreamedUnaryMethod_FileSize<WithStreamedUnaryMethod_FileControl<WithStreamedUnaryMethod_SectorSize<WithStreamedUnaryMethod_DeviceCharacteristics<WithStreamedUnaryMethod_Close<WithStreamedUnaryMethod_Lock<WithStreamedUnaryMethod_Unlock<WithStreamedUnaryMethod_CheckReservedLock<WithStreamedUnaryMethod_Fetch<WithStreamedUnaryMethod_Unfetch<Service > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace os_remote


#endif  // GRPC_os_5fremote_2eproto__INCLUDED
